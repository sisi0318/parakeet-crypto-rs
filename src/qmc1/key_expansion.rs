#[inline]
fn copy_slice<const REVERSE: bool>(destination: &mut [u8], source: &[u8]) {
    debug_assert_eq!(destination.len(), source.len());

    if REVERSE {
        let n = source.len();
        for (i, v) in destination.iter_mut().enumerate() {
            *v = source[n - 1 - i];
        }
    } else {
        destination.copy_from_slice(source);
    }
}

#[inline]
fn expand_key58_to_key64<const REVERSE: bool>(key58: &[u8; 58], key64: &mut [u8]) {
    let row_marker = key58[0];
    let col_marker = key58[1];
    let key56 = &key58[2..];

    for y in 0usize..8 {
        let i = y * 8;
        key64[i] = if y & 1 == 0 { row_marker } else { col_marker };

        let range = if REVERSE {
            (7 - y) * 7..(7 - y) * 7 + 7
        } else {
            y * 7..y * 7 + 7
        };

        copy_slice::<REVERSE>(&mut key64[i + 1..i + 8], &key56[range]);
    }
}

#[inline]
pub fn expand_key58_to_key128(key58: &[u8; 58]) -> [u8; 128] {
    let mut key128 = [0; 128];
    expand_key58_to_key64::<false>(key58, &mut key128[..64]);
    expand_key58_to_key64::<true>(key58, &mut key128[64..]);
    key128
}

#[inline]
pub fn reduce_key256_to_key128(key: &[u8; 256]) -> [u8; 128] {
    let mut key128 = [0u8; 128];
    for (i, v) in key128.iter_mut().enumerate() {
        *v = key[(i * i) % key.len()];
    }

    key128
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_key_expansion() {
        let input = [
            0xFF, 0xFE, //
            0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, //
            0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, //
            0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, //
            0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, //
            0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, //
            0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, //
            0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, //
        ];

        let expected = [
            0xff, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, //
            0xfe, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, //
            0xff, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, //
            0xfe, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, //
            0xff, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, //
            0xfe, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, //
            0xff, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, //
            0xfe, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, //
            0xff, 0x38, 0x37, 0x36, 0x35, 0x34, 0x33, 0x32, //
            0xfe, 0x31, 0x30, 0x2f, 0x2e, 0x2d, 0x2c, 0x2b, //
            0xff, 0x2a, 0x29, 0x28, 0x27, 0x26, 0x25, 0x24, //
            0xfe, 0x23, 0x22, 0x21, 0x20, 0x1f, 0x1e, 0x1d, //
            0xff, 0x1c, 0x1b, 0x1a, 0x19, 0x18, 0x17, 0x16, //
            0xfe, 0x15, 0x14, 0x13, 0x12, 0x11, 0x10, 0x0f, //
            0xff, 0x0e, 0x0d, 0x0c, 0x0b, 0x0a, 0x09, 0x08, //
            0xfe, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01, //
        ];

        let actual = expand_key58_to_key128(&input);
        assert_eq!(actual, expected);
    }
}
